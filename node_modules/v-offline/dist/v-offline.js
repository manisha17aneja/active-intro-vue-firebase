/*!
 * v-offline v2.2.4
 * Offline and Online components for Vue
 * (c) 2021 Vinayak Kulkarni<inbox.vinayak@gmail.com>
 * Released under the MIT License
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vue/composition-api'), require('ping.js')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vue/composition-api', 'ping.js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VOffline = {}, global.vueCompositionApi, global.ping));
})(this, (function (exports, VueCompositionApi, Ping) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var VueCompositionApi__default = /*#__PURE__*/_interopDefaultLegacy(VueCompositionApi);
  var Ping__default = /*#__PURE__*/_interopDefaultLegacy(Ping);

  var script = VueCompositionApi.defineComponent({
    name: 'VOffline',
    props: {
      onlineClass: {
        type: String ,
        required: false,
        default: '',
      },
      offlineClass: {
        type: String ,
        required: false,
        default: '',
      },
      pingUrl: {
        type: String ,
        required: false,
        default: 'https://google.com',
      },
    },
    setup(props, { emit }) {
      // Local state
      const isOnline = VueCompositionApi.ref(navigator.onLine || false);
      const events = VueCompositionApi.ref(['online', 'offline', 'load']);
      const url = VueCompositionApi.ref(props.pingUrl || 'https://google.com');

      // Local computed
      const wrapperClass = VueCompositionApi.computed(() => {
        if (isOnline.value) {
          return typeof props.onlineClass === 'string' ? props.onlineClass : '';
        } else {
          return typeof props.offlineClass === 'string'
            ? props.offlineClass
            : '';
        }
      });

      /**
       * Created lifecycle hook
       */
      events.value.forEach((event) => window.addEventListener(event, check));

      /**
       * Before unmount lifecycle hook
       */
      VueCompositionApi.onBeforeUnmount(() => {
        // Cleanup of the event listeners
        events.value.forEach((event) =>
          window.removeEventListener(event, check),
        );
      });

      // Local functions
      /**
       * Pings the URL and emits an
       * detected online/offline event.
       *
       * @returns {Promise<void>}
       */
      async function check() {
        const p = new Ping__default["default"]();
        try {
          const ping = await p.ping(url.value);
          if (ping || navigator.onLine) {
            isOnline.value = true;
            emit('detected-condition', isOnline.value);
          }
        } catch (error) {
          if (error || !navigator.onLine) {
            isOnline.value = false;
            emit('detected-condition', isOnline.value);
          }
        }
      }

      return {
        wrapperClass,
      };
    },
  });

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
      }
      // Vue.extend constructor export interop.
      const options = typeof script === 'function' ? script.options : script;
      // render functions
      if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true;
          // functional template
          if (isFunctionalTemplate) {
              options.functional = true;
          }
      }
      // scopedId
      if (scopeId) {
          options._scopeId = scopeId;
      }
      let hook;
      if (moduleIdentifier) {
          // server build
          hook = function (context) {
              // 2.3 injection
              context =
                  context || // cached call
                      (this.$vnode && this.$vnode.ssrContext) || // stateful
                      (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
              // 2.2 with runInNewContext: true
              if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                  context = __VUE_SSR_CONTEXT__;
              }
              // inject component styles
              if (style) {
                  style.call(this, createInjectorSSR(context));
              }
              // register component module identifier for async chunk inference
              if (context && context._registeredComponents) {
                  context._registeredComponents.add(moduleIdentifier);
              }
          };
          // used by ssr in case component is cached and beforeCreate
          // never gets called
          options._ssrRegister = hook;
      }
      else if (style) {
          hook = shadowMode
              ? function (context) {
                  style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
              }
              : function (context) {
                  style.call(this, createInjector(context));
              };
      }
      if (hook) {
          if (options.functional) {
              // register for functional component in vue file
              const originalRender = options.render;
              options.render = function renderWithStyleInjection(h, context) {
                  hook.call(context);
                  return originalRender(h, context);
              };
          }
          else {
              // inject component registration as beforeCreate hook
              const existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
      }
      return script;
  }

  /* script */
  const __vue_script__ = script;

  /* template */
  var __vue_render__ = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { class: _vm.wrapperClass }, [_vm._t("default")], 2)
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    const __vue_inject_styles__ = undefined;
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__ = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      false,
      undefined,
      undefined,
      undefined
    );

    var VOffline = __vue_component__;

  let installed = false;

  const install = {
    install(Vue) {
      if (installed) return;
      Vue.use(VueCompositionApi__default["default"]);
      Vue.component('VOffline', VOffline);
      installed = true;
    },
  };

  var install$1 = install;

  exports.VOffline = VOffline;
  exports["default"] = install$1;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=v-offline.js.map
