{"remainingRequest":"/var/www/html/active-intro/node_modules/vue-loader/lib/index.js??vue-loader-options!/var/www/html/active-intro/node_modules/vue-google-autocomplete/src/VueGoogleAutocomplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"/var/www/html/active-intro/node_modules/vue-google-autocomplete/src/VueGoogleAutocomplete.vue","mtime":499162500000},{"path":"/var/www/html/active-intro/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/var/www/html/active-intro/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/var/www/html/active-intro/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/var/www/html/active-intro/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCiAgICBjb25zdCBBRERSRVNTX0NPTVBPTkVOVFMgPSB7CiAgICAgICAgc3VicHJlbWlzZSA6ICdzaG9ydF9uYW1lJywKICAgICAgICBzdHJlZXRfbnVtYmVyOiAnc2hvcnRfbmFtZScsCiAgICAgICAgcm91dGU6ICdsb25nX25hbWUnLAogICAgICAgIGxvY2FsaXR5OiAnbG9uZ19uYW1lJywKICAgICAgICBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzE6ICdzaG9ydF9uYW1lJywKICAgICAgICBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzI6ICdsb25nX25hbWUnLAogICAgICAgIGNvdW50cnk6ICdsb25nX25hbWUnLAogICAgICAgIHBvc3RhbF9jb2RlOiAnc2hvcnRfbmFtZScKICAgIH07CgogICAgY29uc3QgQ0lUSUVTX1RZUEUgPSBbJ2xvY2FsaXR5JywgJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMyddOwogICAgY29uc3QgUkVHSU9OU19UWVBFID0gWydsb2NhbGl0eScsICdzdWJsb2NhbGl0eScsICdwb3N0YWxfY29kZScsICdjb3VudHJ5JywKICAgICAgICAnYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8xJywgJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMiddOwoKICAgIC8qCiAgICAgIEJ5IGRlZmF1bHQsIHdlJ3JlIG9ubHkgaW5jbHVkaW5nIGJhc2ljIHBsYWNlIGRhdGEgYmVjYXVzZSByZXF1ZXN0aW5nIHRoZXNlIAogICAgICBmaWVsZHMgcGxhY2UgZGF0YSBpcyBub3QgYWRkaXRpb25hbGx5IGNoYXJnZWQgYnkgR29vZ2xlLiBQbGVhc2UgcmVmZXIgdG86CgogICAgICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2JpbGxpbmcvdW5kZXJzdGFuZGluZy1jb3N0LW9mLXVzZSNiYXNpYy1kYXRhCiAgICAqLwogICAgY29uc3QgQkFTSUNfREFUQV9GSUVMRFMgPSBbJ2FkZHJlc3NfY29tcG9uZW50cycsICdhZHJfYWRkcmVzcycsICdhbHRfaWQnLCAKICAgICAgICAnZm9ybWF0dGVkX2FkZHJlc3MnLCAnZ2VvbWV0cnknLCAnaWNvbicsICdpZCcsICduYW1lJywgCiAgICAgICAgJ3Blcm1hbmVudGx5X2Nsb3NlZCcsICdwaG90bycsICdwbGFjZV9pZCcsICdzY29wZScsICd0eXBlJywgJ3VybCcsIAogICAgICAgICd1dGNfb2Zmc2V0JywgJ3ZpY2luaXR5J107CgogICAgZXhwb3J0IGRlZmF1bHQgewogICAgICAgIG5hbWU6ICdWdWVHb29nbGVBdXRvY29tcGxldGUnLAoKICAgICAgICBwcm9wczogewogICAgICAgICAgaWQ6IHsKICAgICAgICAgICAgdHlwZTogU3RyaW5nLAogICAgICAgICAgICByZXF1aXJlZDogdHJ1ZQogICAgICAgICAgfSwKCiAgICAgICAgICBjbGFzc25hbWU6IFN0cmluZywKCiAgICAgICAgICBwbGFjZWhvbGRlcjogewogICAgICAgICAgICB0eXBlOiBTdHJpbmcsCiAgICAgICAgICAgIGRlZmF1bHQ6ICdTdGFydCB0eXBpbmcnCiAgICAgICAgICB9LAoKICAgICAgICAgIGRpc2FibGVkOiB7CiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICB9LAoKICAgICAgICAgIHR5cGVzOiB7CiAgICAgICAgICAgIHR5cGU6IFN0cmluZywKICAgICAgICAgICAgZGVmYXVsdDogJ2FkZHJlc3MnCiAgICAgICAgICB9LAoKICAgICAgICAgIGZpZWxkczogewogICAgICAgICAgICB0eXBlOiBBcnJheSwKICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJBU0lDX0RBVEFfRklFTERTOwogICAgICAgICAgICB9LAogICAgICAgICAgfSwKCiAgICAgICAgICBjb3VudHJ5OiB7CiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSwKICAgICAgICAgICAgZGVmYXVsdDogbnVsbAogICAgICAgICAgfSwKCiAgICAgICAgICBlbmFibGVHZW9sb2NhdGlvbjogewogICAgICAgICAgICB0eXBlOiBCb29sZWFuLAogICAgICAgICAgICBkZWZhdWx0OiBmYWxzZQogICAgICAgICAgfSwKCiAgICAgICAgICBnZW9sb2NhdGlvbk9wdGlvbnM6IHsKICAgICAgICAgICAgdHlwZTogT2JqZWN0LAogICAgICAgICAgICBkZWZhdWx0OiBudWxsCiAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZGF0YSgpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgICAgICogVGhlIEF1dG9jb21wbGV0ZSBvYmplY3QuCiAgICAgICAgICAgICAgICAgKgogICAgICAgICAgICAgICAgICogQHR5cGUge0F1dG9jb21wbGV0ZX0KICAgICAgICAgICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNBdXRvY29tcGxldGUKICAgICAgICAgICAgICAgICAqLwogICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBudWxsLAoKICAgICAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgICAgICogQXV0b2NvbXBsZXRlIGlucHV0IHRleHQKICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9CiAgICAgICAgICAgICAgICAgKi8KICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZVRleHQ6ICcnLAoKICAgICAgICAgICAgICAgIGdlb2xvY2F0aW9uOiB7CiAgICAgICAgICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAgICAgICAgICogR29vZ2xlIEdlb2NvZGVyIE9iamV0CiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge0dlb2NvZGVyfQogICAgICAgICAgICAgICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNHZW9jb2RlcgogICAgICAgICAgICAgICAgICAgICAqLwogICAgICAgICAgICAgICAgICAgIGdlb2NvZGVyOiBudWxsLAoKICAgICAgICAgICAgICAgICAgICAvKioKICAgICAgICAgICAgICAgICAgICAgKiBGaWxsZWQgYWZ0ZXIgZ2VvbG9jYXRlIHJlc3VsdAogICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHtDb29yZGluYXRlc30KICAgICAgICAgICAgICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ29vcmRpbmF0ZXMKICAgICAgICAgICAgICAgICAgICAgKi8KICAgICAgICAgICAgICAgICAgICBsb2M6IG51bGwsCgogICAgICAgICAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgICAgICAgICAqIEZpbGxlZCBhZnRlciBnZW9sb2NhdGUgcmVzdWx0CiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge1Bvc2l0aW9ufQogICAgICAgICAgICAgICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb3NpdGlvbgogICAgICAgICAgICAgICAgICAgICAqLwogICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudWxsCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICB3YXRjaDogewogICAgICAgICAgICBhdXRvY29tcGxldGVUZXh0OiBmdW5jdGlvbiAobmV3VmFsLCBvbGRWYWwpIHsKCSAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0Q2hhbmdlJywgeyBuZXdWYWwsIG9sZFZhbCB9LCB0aGlzLmlkKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgY291bnRyeTogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHsKICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRDb21wb25lbnRSZXN0cmljdGlvbnMoewogICAgICAgICAgICAgICAgY291bnRyeTogdGhpcy5jb3VudHJ5ID09PSBudWxsID8gW10gOiB0aGlzLmNvdW50cnkKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9OwoKICAgICAgICAgIGlmICh0aGlzLnR5cGVzKSB7CiAgICAgICAgICAgIG9wdGlvbnMudHlwZXMgPSBbdGhpcy50eXBlc107CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKHRoaXMuY291bnRyeSkgewogICAgICAgICAgICBvcHRpb25zLmNvbXBvbmVudFJlc3RyaWN0aW9ucyA9IHsKICAgICAgICAgICAgICBjb3VudHJ5OiB0aGlzLmNvdW50cnkKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlKAogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCksCiAgICAgICAgICAgICAgICBvcHRpb25zCiAgICAgICAgICAgICk7CgogICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuc2V0RmllbGRzKHRoaXMuZmllbGRzKTsKCiAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5hZGRMaXN0ZW5lcigncGxhY2VfY2hhbmdlZCcsIHRoaXMub25QbGFjZUNoYW5nZWQpOwogICAgICAgIH0sCgogICAgICAgIG1ldGhvZHM6IHsKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIFdoZW4gYSBwbGFjZSBjaGFuZ2VkCiAgICAgICAgICAgICAqLwogICAgICAgICAgICBvblBsYWNlQ2hhbmdlZCgpIHsKICAgICAgICAgICAgICAgIGxldCBwbGFjZSA9IHRoaXMuYXV0b2NvbXBsZXRlLmdldFBsYWNlKCk7CgogICAgICAgICAgICAgICAgaWYgKCFwbGFjZS5nZW9tZXRyeSkgewogICAgICAgICAgICAgICAgICAvLyBVc2VyIGVudGVyZWQgdGhlIG5hbWUgb2YgYSBQbGFjZSB0aGF0IHdhcyBub3Qgc3VnZ2VzdGVkIGFuZAogICAgICAgICAgICAgICAgICAvLyBwcmVzc2VkIHRoZSBFbnRlciBrZXksIG9yIHRoZSBQbGFjZSBEZXRhaWxzIHJlcXVlc3QgZmFpbGVkLgogICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCduby1yZXN1bHRzLWZvdW5kJywgcGxhY2UsIHRoaXMuaWQpOwogICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKHBsYWNlLmFkZHJlc3NfY29tcG9uZW50cyAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJldHVybkRhdGEgb2JqZWN0IGFuZCBQbGFjZVJlc3VsdCBvYmplY3QKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdwbGFjZWNoYW5nZWQnLCB0aGlzLmZvcm1hdFJlc3VsdChwbGFjZSksIHBsYWNlLCB0aGlzLmlkKTsKCiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGF1dG9jb21wbGV0ZVRleHQgdGhlbiBlbWl0IGNoYW5nZSBldmVudAogICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpLnZhbHVlCiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogV2hlbiB0aGUgaW5wdXQgZ2V0cyBmb2N1cwogICAgICAgICAgICAgKi8KICAgICAgICAgICAgb25Gb2N1cygpIHsKICAgICAgICAgICAgICB0aGlzLmJpYXNBdXRvY29tcGxldGVMb2NhdGlvbigpOwogICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJyk7CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogV2hlbiB0aGUgaW5wdXQgbG9zZXMgZm9jdXMKICAgICAgICAgICAgICovCiAgICAgICAgICAgIG9uQmx1cigpIHsKICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdibHVyJyk7CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogV2hlbiB0aGUgaW5wdXQgZ290IGNoYW5nZWQKICAgICAgICAgICAgICovCiAgICAgICAgICAgIG9uQ2hhbmdlKCkgewogICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuYXV0b2NvbXBsZXRlVGV4dCk7CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogV2hlbiBhIGtleSBnZXRzIHByZXNzZWQKICAgICAgICAgICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IEEga2V5cHJlc3MgZXZlbnQKICAgICAgICAgICAgICovCiAgICAgICAgICAgIG9uS2V5UHJlc3MoZXZlbnQpIHsKICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdrZXlwcmVzcycsIGV2ZW50KTsKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBXaGVuIGEga2V5dXAgb2NjdXJzCiAgICAgICAgICAgICAqIEBwYXJhbSAge0V2ZW50fSBldmVudCBBIGtleXVwIGV2ZW50CiAgICAgICAgICAgICAqLwogICAgICAgICAgICBvbktleVVwKGV2ZW50KSB7CiAgICAgICAgICAgICAgdGhpcy4kZW1pdCgna2V5dXAnLCBldmVudCk7CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogQ2xlYXIgdGhlIGlucHV0CiAgICAgICAgICAgICAqLwogICAgICAgICAgICBjbGVhcigpIHsKICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZVRleHQgPSAnJwogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIEZvY3VzIHRoZSBpbnB1dAogICAgICAgICAgICAgKi8KICAgICAgICAgICAgZm9jdXMoKSB7CiAgICAgICAgICAgICAgdGhpcy4kcmVmcy5hdXRvY29tcGxldGUuZm9jdXMoKQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIEJsdXIgdGhlIGlucHV0CiAgICAgICAgICAgICAqLwogICAgICAgICAgICBibHVyKCkgewogICAgICAgICAgICAgIHRoaXMuJHJlZnMuYXV0b2NvbXBsZXRlLmJsdXIoKQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIGlucHV0CiAgICAgICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gdmFsdWUKICAgICAgICAgICAgICovCiAgICAgICAgICAgIHVwZGF0ZSAodmFsdWUpIHsKICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZVRleHQgPSB2YWx1ZQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGlucHV0CiAgICAgICAgICAgICAqIEBwYXJhbSAge0Nvb3JkaW5hdGVzfSB2YWx1ZQogICAgICAgICAgICAgKi8KICAgICAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZXMgKHZhbHVlKSB7CiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlICYmICEodmFsdWUubGF0IHx8IHZhbHVlLmxuZykpIHJldHVybjsKICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZW9sb2NhdGlvbi5nZW9jb2RlcikgdGhpcy5nZW9sb2NhdGlvbi5nZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlcigpOwogICAgICAgICAgICAgICAgdGhpcy5nZW9sb2NhdGlvbi5nZW9jb2Rlci5nZW9jb2RlKHsnbG9jYXRpb24nOiB2YWx1ZX0sIChyZXN1bHRzLCBzdGF0dXMpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnT0snKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLmZpbHRlckdlb2NvZGVSZXN1bHRUeXBlcyhyZXN1bHRzKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbMF0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3BsYWNlY2hhbmdlZCcsIHRoaXMuZm9ybWF0UmVzdWx0KHJlc3VsdHNbMF0pLCByZXN1bHRzWzBdLCB0aGlzLmlkKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHJlc3VsdHNbMF0uZm9ybWF0dGVkX2FkZHJlc3MpOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCAnbm8gcmVzdWx0IGZvciBwcm92aWRlZCBjb29yZGluYXRlcycpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCAnZXJyb3IgZ2V0dGluZyBhZGRyZXNzIGZyb20gY29vcmRzJyk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBVcGRhdGUgbG9jYXRpb24gYmFzZWQgb24gbmF2aWdhdG9yIGdlb2xvY2F0aW9uCiAgICAgICAgICAgICAqLwogICAgICAgICAgICBnZW9sb2NhdGUgKCkgewogICAgICAgICAgICAgICAgdGhpcy51cGRhdGVHZW9sb2NhdGlvbiAoKGdlb2xvY2F0aW9uLCBwb3NpdGlvbikgPT4gewogICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29vcmRpbmF0ZXMoZ2VvbG9jYXRpb24pCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIFVwZGF0ZSBpbnRlcm5hbCBsb2NhdGlvbiBmcm9tIG5hdmlnYXRvciBnZW9sb2NhdGlvbgogICAgICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gKGdlb2xvY2F0aW9uLCBwb3NpdGlvbikKICAgICAgICAgICAgICovCiAgICAgICAgICAgIHVwZGF0ZUdlb2xvY2F0aW9uIChjYWxsYmFjayA9IG51bGwpIHsKICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHsKICAgICAgICAgICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHt9OwogICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2VvbG9jYXRpb25PcHRpb25zKSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMuZ2VvbG9jYXRpb25PcHRpb25zKTsKICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKHBvc2l0aW9uID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdlb2xvY2F0aW9uID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUKICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW9sb2NhdGlvbi5sb2MgPSBnZW9sb2NhdGlvbjsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW9sb2NhdGlvbi5wb3NpdGlvbiA9IHBvc2l0aW9uOwoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhnZW9sb2NhdGlvbiwgcG9zaXRpb24pOwogICAgICAgICAgICAgICAgICAgIH0sIGVyciA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgJ0Nhbm5vdCBnZXQgQ29vcmRpbmF0ZXMgZnJvbSBuYXZpZ2F0b3InLCBlcnIpOwogICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAoKCiAgICAgICAgICAgIC8vIEJpYXMgdGhlIGF1dG9jb21wbGV0ZSBvYmplY3QgdG8gdGhlIHVzZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24sCiAgICAgICAgICAgIC8vIGFzIHN1cHBsaWVkIGJ5IHRoZSBicm93c2VyJ3MgJ25hdmlnYXRvci5nZW9sb2NhdGlvbicgb2JqZWN0LgogICAgICAgICAgICBiaWFzQXV0b2NvbXBsZXRlTG9jYXRpb24gKCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlR2VvbG9jYXRpb24pIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUdlb2xvY2F0aW9uKChnZW9sb2NhdGlvbiwgcG9zaXRpb24pID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNpcmNsZSA9IG5ldyBnb29nbGUubWFwcy5DaXJjbGUoewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiBnZW9sb2NhdGlvbiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5CiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRCb3VuZHMoY2lyY2xlLmdldEJvdW5kcygpKTsKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIEZvcm1hdCByZXN1bHQgZnJvbSBHZW8gZ29vZ2xlIEFQSXMKICAgICAgICAgICAgICogQHBhcmFtIHBsYWNlCiAgICAgICAgICAgICAqIEByZXR1cm5zIHt7Zm9ybWF0dGVkIG91dHB1dH19CiAgICAgICAgICAgICAqLwogICAgICAgICAgICBmb3JtYXRSZXN1bHQgKHBsYWNlKSB7CiAgICAgICAgICAgICAgICBsZXQgcmV0dXJuRGF0YSA9IHt9OwogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBsZXQgYWRkcmVzc1R5cGUgPSBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHNbaV0udHlwZXNbMF07CgogICAgICAgICAgICAgICAgICAgIGlmIChBRERSRVNTX0NPTVBPTkVOVFNbYWRkcmVzc1R5cGVdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHNbaV1bQUREUkVTU19DT01QT05FTlRTW2FkZHJlc3NUeXBlXV07CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGFbYWRkcmVzc1R5cGVdID0gdmFsOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXR1cm5EYXRhWydsYXRpdHVkZSddID0gcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24ubGF0KCk7CiAgICAgICAgICAgICAgICByZXR1cm5EYXRhWydsb25naXR1ZGUnXSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpOwogICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkRhdGEKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBFeHRyYWN0IGNvbmZpZ3VyZWQgdHlwZXMgb3V0IG9mIHJhdyByZXN1bHQgYXMKICAgICAgICAgICAgICogR2VvY29kZSBBUEkgZG9lcyBub3QgYWxsb3cgdG8gZG8gaXQKICAgICAgICAgICAgICogQHBhcmFtIHJlc3VsdHMKICAgICAgICAgICAgICogQHJldHVybnMge0dlb2NvZGVyUmVzdWx0fQogICAgICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjR2VvY29kZXJSZXN1bHQKICAgICAgICAgICAgICovCiAgICAgICAgICAgIGZpbHRlckdlb2NvZGVSZXN1bHRUeXBlcyAocmVzdWx0cykgewogICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzIHx8ICF0aGlzLnR5cGVzKSByZXR1cm4gcmVzdWx0czsKICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBbXTsKICAgICAgICAgICAgICAgIGxldCB0eXBlcyA9IFt0aGlzLnR5cGVzXTsKICAgICAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcygnKGNpdGllcyknKSkgdHlwZXMgPSB0eXBlcy5jb25jYXQoQ0lUSUVTX1RZUEUpOwogICAgICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCcocmVnaW9ucyknKSkgdHlwZXMgPSB0eXBlcy5jb25jYXQoUkVHSU9OU19UWVBFKTsKCiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHJlc3VsdHMpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHIudHlwZXMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKHQpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0K"},{"version":3,"sources":["VueGoogleAutocomplete.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"VueGoogleAutocomplete.vue","sourceRoot":"node_modules/vue-google-autocomplete/src","sourcesContent":["<template>\n    <input\n        ref=\"autocomplete\"\n        type=\"text\"\n        :class=\"classname\"\n        :id=\"id\"\n        :placeholder=\"placeholder\"\n        :disabled=\"disabled\"\n        v-model=\"autocompleteText\"\n        @focus=\"onFocus()\"\n        @blur=\"onBlur()\"\n        @change=\"onChange\"\n        @keypress=\"onKeyPress\"\n        @keyup=\"onKeyUp\"\n    />\n</template>\n\n<script>\n    const ADDRESS_COMPONENTS = {\n        subpremise : 'short_name',\n        street_number: 'short_name',\n        route: 'long_name',\n        locality: 'long_name',\n        administrative_area_level_1: 'short_name',\n        administrative_area_level_2: 'long_name',\n        country: 'long_name',\n        postal_code: 'short_name'\n    };\n\n    const CITIES_TYPE = ['locality', 'administrative_area_level_3'];\n    const REGIONS_TYPE = ['locality', 'sublocality', 'postal_code', 'country',\n        'administrative_area_level_1', 'administrative_area_level_2'];\n\n    /*\n      By default, we're only including basic place data because requesting these \n      fields place data is not additionally charged by Google. Please refer to:\n\n      https://developers.google.com/maps/billing/understanding-cost-of-use#basic-data\n    */\n    const BASIC_DATA_FIELDS = ['address_components', 'adr_address', 'alt_id', \n        'formatted_address', 'geometry', 'icon', 'id', 'name', \n        'permanently_closed', 'photo', 'place_id', 'scope', 'type', 'url', \n        'utc_offset', 'vicinity'];\n\n    export default {\n        name: 'VueGoogleAutocomplete',\n\n        props: {\n          id: {\n            type: String,\n            required: true\n          },\n\n          classname: String,\n\n          placeholder: {\n            type: String,\n            default: 'Start typing'\n          },\n\n          disabled: {\n            type: Boolean,\n            default: false\n          },\n\n          types: {\n            type: String,\n            default: 'address'\n          },\n\n          fields: {\n            type: Array,\n            default: function() {\n              return BASIC_DATA_FIELDS;\n            },\n          },\n\n          country: {\n            type: [String, Array],\n            default: null\n          },\n\n          enableGeolocation: {\n            type: Boolean,\n            default: false\n          },\n\n          geolocationOptions: {\n            type: Object,\n            default: null\n          }\n        },\n\n        data() {\n            return {\n                /**\n                 * The Autocomplete object.\n                 *\n                 * @type {Autocomplete}\n                 * @link https://developers.google.com/maps/documentation/javascript/reference#Autocomplete\n                 */\n                autocomplete: null,\n\n                /**\n                 * Autocomplete input text\n                 * @type {String}\n                 */\n                autocompleteText: '',\n\n                geolocation: {\n                    /**\n                     * Google Geocoder Objet\n                     * @type {Geocoder}\n                     * @link https://developers.google.com/maps/documentation/javascript/reference#Geocoder\n                     */\n                    geocoder: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Coordinates}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Coordinates\n                     */\n                    loc: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Position}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Position\n                     */\n                    position: null\n                }\n            }\n        },\n\n        watch: {\n            autocompleteText: function (newVal, oldVal) {\n\t            this.$emit('inputChange', { newVal, oldVal }, this.id);\n            },\n            country: function(newVal, oldVal) {\n              this.autocomplete.setComponentRestrictions({\n                country: this.country === null ? [] : this.country\n              });\n            }\n        },\n\n        mounted: function() {\n          const options = {};\n\n          if (this.types) {\n            options.types = [this.types];\n          }\n\n          if (this.country) {\n            options.componentRestrictions = {\n              country: this.country\n            };\n          }\n\n          this.autocomplete = new google.maps.places.Autocomplete(\n                document.getElementById(this.id),\n                options\n            );\n\n          this.autocomplete.setFields(this.fields);\n\n          this.autocomplete.addListener('place_changed', this.onPlaceChanged);\n        },\n\n        methods: {\n            /**\n             * When a place changed\n             */\n            onPlaceChanged() {\n                let place = this.autocomplete.getPlace();\n\n                if (!place.geometry) {\n                  // User entered the name of a Place that was not suggested and\n                  // pressed the Enter key, or the Place Details request failed.\n                  this.$emit('no-results-found', place, this.id);\n                  return;\n                }\n\n                if (place.address_components !== undefined) {\n                    // return returnData object and PlaceResult object\n                    this.$emit('placechanged', this.formatResult(place), place, this.id);\n\n                    // update autocompleteText then emit change event\n                    this.autocompleteText = document.getElementById(this.id).value\n                    this.onChange()\n                }\n            },\n\n            /**\n             * When the input gets focus\n             */\n            onFocus() {\n              this.biasAutocompleteLocation();\n              this.$emit('focus');\n            },\n\n            /**\n             * When the input loses focus\n             */\n            onBlur() {\n              this.$emit('blur');\n            },\n\n            /**\n             * When the input got changed\n             */\n            onChange() {\n              this.$emit('change', this.autocompleteText);\n            },\n\n            /**\n             * When a key gets pressed\n             * @param  {Event} event A keypress event\n             */\n            onKeyPress(event) {\n              this.$emit('keypress', event);\n            },\n\n            /**\n             * When a keyup occurs\n             * @param  {Event} event A keyup event\n             */\n            onKeyUp(event) {\n              this.$emit('keyup', event);\n            },\n\n            /**\n             * Clear the input\n             */\n            clear() {\n              this.autocompleteText = ''\n            },\n\n            /**\n             * Focus the input\n             */\n            focus() {\n              this.$refs.autocomplete.focus()\n            },\n\n            /**\n             * Blur the input\n             */\n            blur() {\n              this.$refs.autocomplete.blur()\n            },\n\n            /**\n             * Update the value of the input\n             * @param  {String} value\n             */\n            update (value) {\n              this.autocompleteText = value\n            },\n\n            /**\n             * Update the coordinates of the input\n             * @param  {Coordinates} value\n             */\n            updateCoordinates (value) {\n                if (!value && !(value.lat || value.lng)) return;\n                if (!this.geolocation.geocoder) this.geolocation.geocoder = new google.maps.Geocoder();\n                this.geolocation.geocoder.geocode({'location': value}, (results, status) => {\n                    if (status === 'OK') {\n                        results = this.filterGeocodeResultTypes(results);\n                        if (results[0]) {\n                            this.$emit('placechanged', this.formatResult(results[0]), results[0], this.id);\n                            this.update(results[0].formatted_address);\n                        } else {\n                            this.$emit('error', 'no result for provided coordinates');\n                        }\n                    } else {\n                        this.$emit('error', 'error getting address from coords');\n                    }\n                })\n            },\n\n            /**\n             * Update location based on navigator geolocation\n             */\n            geolocate () {\n                this.updateGeolocation ((geolocation, position) => {\n                    this.updateCoordinates(geolocation)\n                })\n            },\n\n            /**\n             * Update internal location from navigator geolocation\n             * @param  {Function} (geolocation, position)\n             */\n            updateGeolocation (callback = null) {\n                if (navigator.geolocation) {\n                    let options = {};\n                    if(this.geolocationOptions) Object.assign(options, this.geolocationOptions);\n                    navigator.geolocation.getCurrentPosition(position => {\n                        let geolocation = {\n                            lat: position.coords.latitude,\n                            lng: position.coords.longitude\n                        };\n                        this.geolocation.loc = geolocation;\n                        this.geolocation.position = position;\n\n                        if (callback) callback(geolocation, position);\n                    }, err => {\n                        this.$emit('error', 'Cannot get Coordinates from navigator', err);\n                    }, options);\n                }\n            },\n\n\n            // Bias the autocomplete object to the user's geographical location,\n            // as supplied by the browser's 'navigator.geolocation' object.\n            biasAutocompleteLocation () {\n                if (this.enableGeolocation) {\n                    this.updateGeolocation((geolocation, position) => {\n                        let circle = new google.maps.Circle({\n                            center: geolocation,\n                            radius: position.coords.accuracy\n                        });\n                        this.autocomplete.setBounds(circle.getBounds());\n                    })\n                }\n            },\n\n            /**\n             * Format result from Geo google APIs\n             * @param place\n             * @returns {{formatted output}}\n             */\n            formatResult (place) {\n                let returnData = {};\n                for (let i = 0; i < place.address_components.length; i++) {\n                    let addressType = place.address_components[i].types[0];\n\n                    if (ADDRESS_COMPONENTS[addressType]) {\n                        let val = place.address_components[i][ADDRESS_COMPONENTS[addressType]];\n                        returnData[addressType] = val;\n                    }\n                }\n\n                returnData['latitude'] = place.geometry.location.lat();\n                returnData['longitude'] = place.geometry.location.lng();\n                return returnData\n            },\n\n            /**\n             * Extract configured types out of raw result as\n             * Geocode API does not allow to do it\n             * @param results\n             * @returns {GeocoderResult}\n             * @link https://developers.google.com/maps/documentation/javascript/reference#GeocoderResult\n             */\n            filterGeocodeResultTypes (results) {\n                if (!results || !this.types) return results;\n                let output = [];\n                let types = [this.types];\n                if (types.includes('(cities)')) types = types.concat(CITIES_TYPE);\n                if (types.includes('(regions)')) types = types.concat(REGIONS_TYPE);\n\n                for (let r of results) {\n                    for (let t of r.types) {\n                        if (types.includes(t)) {\n                            output.push(r);\n                            break;\n                        }\n                    }\n                }\n                return output;\n            }\n        }\n    }\n</script>\n"]}]}